use clap::{Args, Parser};
use ruma::{OwnedRoomAliasId, OwnedServerName, RoomAliasId, RoomId, RoomVersionId, ServerName, UserId, EventId, MxcUri};
use std::time::{Duration, SystemTime};

#[cfg_attr(test, derive(Debug))]
#[derive(Parser)]
#[command(
    name = "@conduit:server.name:",
    version = env!("CARGO_PKG_VERSION"),
    long_about = "Welcome to the Conduit administration room.

You can run commands by sending a message in this room.

Commands must be prefixed with the bot's user ID, e.g.:
@conduit:server.name: command --arg

If the Conduit admin is the only bot in the room, you can also use a shortcut:
!command --arg"
)]
pub enum AdminCommand {
    #[command(verbatim_doc_comment)]
    /// Register an appservice using its registration YAML
    ///
    /// This command needs a YAML generated by an appservice (such as a bridge),
    /// which must be provided in a Markdown code-block below the command.
    ///
    /// Registering a new bridge using the ID of an existing bridge will replace
    /// the old one.
    ///
    /// [commandbody]()
    /// # ```
    /// # yaml content here
    /// # ```
    RegisterAppservice,

    /// Unregister an appservice using its ID
    ///
    /// You can find the ID using the `list-appservices` command.
    UnregisterAppservice {
        /// The appservice to unregister
        appservice_identifier: String,
    },

    /// List all the currently registered appservices
    ListAppservices,

    /// Shows information about a room
    RoomInfo {
        /// The room id or alias to inspect
        room_id_or_alias: String,
    },

    /// List all rooms the server knows about
    ListRooms,

    /// List users in the database
    ListLocalUsers,

    /// List all rooms we are currently handling an incoming pdu from
    IncomingFederation,

    /// Removes an alias from the server
    RemoveAlias {
        /// The alias to be removed
        alias: Box<RoomAliasId>,
    },

    /// Deactivate a user
    ///
    /// User will not be removed from all rooms by default.
    /// Use --leave-rooms to force the user to leave all rooms.
    DeactivateUser {
        #[arg(short, long)]
        leave_rooms: bool,
        user_id: Box<UserId>,
        #[command(flatten)]
        purge_media: DeactivatePurgeMediaArgs,
    },

    #[command(verbatim_doc_comment)]
    /// Deactivate a list of users
    ///
    /// Recommended to use in conjunction with list-local-users.
    ///
    /// Use either --purge-all-media or --purge-media-from-last to either delete all media uploaded
    /// by them (in the last {specified timeframe}, if any)
    /// Users will not be removed from joined rooms by default.
    /// Can be overridden with --leave-rooms flag.
    /// Removing a mass amount of users from a room may cause a significant amount of leave events.
    /// The time to leave rooms may depend significantly on joined rooms and servers.
    ///
    /// [commandbody]()
    /// # ```
    /// # User list here
    /// # ```
    DeactivateAll {
        #[arg(short, long)]
        /// Remove users from their joined rooms
        leave_rooms: bool,
        #[arg(short = 'F', long)]
        /// Also deactivate admin accounts
        force: bool,
        #[command(flatten)]
        purge_media: DeactivatePurgeMediaArgs,
    },

    /// Shows information about the requested media
    QueryMedia {
        /// The MXC URI of the media you want to request information about
        mxc: Box<MxcUri>,
    },

    /// Sends a message with the requested media attached, so that you can view it easily
    ShowMedia {
        /// The MXC URI of the media you want to view
        mxc: Box<MxcUri>,
    },

    /// Lists all the media matching the specified requirements
    ListMedia {
        #[command(flatten)]
        user_server_filter: ListMediaArgs,

        /// Whether to include thumbnails in the list.
        /// It is recommended to do so if you are not only looking
        /// for local media, as with remote media, the full media file
        /// might not be downloaded, just the thumbnail
        #[arg(short = 't', long)]
        include_thumbnails: bool,

        #[arg(short, long)]
        /// The content-type media must have to be listed.
        /// if only a "type" (as opposed to "type/subtype") is specified,
        /// all media with that type are returned, no matter the sub-type.
        ///
        /// For example, if you request content-type "image", than files
        /// of content type "image/png", "image/jpeg", etc. will be returned.
        content_type: Option<String>,

        #[arg(
            short = 'b', long,
            value_parser = humantime::parse_rfc3339_weak
        )]
        /// The point in time after which media had to be uploaded to be
        /// shown (in the UTC timezone).
        /// Should be in the format {YYYY}-{MM}-{DD}T{hh}:{mm}:{ss}
        uploaded_before: Option<SystemTime>,

        #[arg(
            short = 'a', long,
            value_parser = humantime::parse_rfc3339_weak
        )]
        /// The point in time before which media had to be uploaded to be
        /// shown (in the UTC timezone).
        /// Should be in the format {YYYY}-{MM}-{DD}T{hh}:{mm}:{ss}
        uploaded_after: Option<SystemTime>,
    },

    /// Purge a list of media, formatted as MXC URIs
    /// There should be one URI per line, all contained within a code-block
    ///
    /// Note: This will also delete media with the same sha256 hash, so
    /// only use this when you are certain all the media is undesirable
    PurgeMedia,

    /// Purges all media uploaded by the local users listed in a code-block.
    ///
    /// Note: This will also delete identical media uploaded by other users, so
    /// only use this when all the media they uploaded is undesirable
    PurgeMediaFromUsers {
        #[arg(
            long, short = 't',
            value_parser = humantime::parse_duration
        )]
        /// Only purge media uploaded in the last {timeframe}
        ///
        /// Should be in the form specified by humantime::parse_duration
        /// (e.g. 48h, 60min, 10days etc.)
        // --help is unformatted
        #[allow(rustdoc::bare_urls)]
        /// https://docs.rs/humantime/2.2.0/humantime/fn.parse_duration.html
        from_last: Option<Duration>,

        #[arg(long, short)]
        /// Also deletes other media with the same SHA256 hash, ensuring that the file is removed from
        /// the media backend, so only use this when all the media they uploaded is undesirable
        force_filehash: bool,
    },

    /// Purges all media from the specified server
    ///
    /// Note: This will also delete identical media uploaded by local users, so
    /// only use this when all the media from that server is undesirable (or if
    /// you know that no media on the remote server is also uploaded locally)
    PurgeMediaFromServer {
        server_id: Box<ServerName>,
        #[arg(
            long, short = 't',
            value_parser = humantime::parse_duration
        )]
        /// Only purge media uploaded in the last {timeframe}
        ///
        /// Should be in the form specified by humantime::parse_duration
        /// (e.g. 48h, 60min, 10days etc.)
        // --help is unformatted
        #[allow(rustdoc::bare_urls)]
        /// https://docs.rs/humantime/2.2.0/humantime/fn.parse_duration.html
        from_last: Option<Duration>,

        #[arg(long, short)]
        /// Also deletes other media with the same SHA256 hash, ensuring that the file is removed from
        /// the media backend, so only use this when all the media they uploaded is undesirable
        force_filehash: bool,
    },

    /// Prevents the list of media from being accessed, but does not delete the media if it
    /// is already downloaded. If the media has already been downloaded, the sha256 hash
    /// is blocked, meaning that any other current or future uploads/downloads of the exact same
    /// content cannot be accessed either.
    ///
    /// There should be one MXC URI per line, all contained within a code-block
    BlockMedia {
        #[arg(long, short)]
        /// Prevents the specified media from being downloaded in the future
        ///
        /// Note: This will also delete identical media uploaded by other users, so
        /// only use this all the media is known to be undesirable
        and_purge: bool,
        #[arg(long, short)]
        /// Optional reason as to why this media should be blocked
        reason: Option<String>,
    },

    /// Prevents all media uploaded by the local users, listed in a code-block, from being accessed
    ///
    /// Note: This will also block media with the same SHA256 hash, so
    /// only use this when all media uploaded by the user is undesirable (or if
    /// you only plan for the bloackage to be temporary)
    BlockMediaFromUsers {
        #[arg(
            long, short,
            value_parser = humantime::parse_duration
        )]
        /// Only block media uploaded in the last {timeframe}
        ///
        /// Should be in the form specified by humantime::parse_duration
        /// (e.g. 48h, 60min, 10days etc.)
        // --help is unformatted
        #[allow(rustdoc::bare_urls)]
        /// https://docs.rs/humantime/2.2.0/humantime/fn.parse_duration.html
        from_last: Option<Duration>,
        #[arg(long, short)]
        /// Optional reason as to why this media should be blocked
        reason: Option<String>,
    },

    /// Lists all media that is currently blocked
    ListBlockedMedia,

    /// Allows previously blocked media to be accessed again. Will also unblock media with the
    /// same SHA256 hash
    /// There should be one MXC URI per line, all contained within a code-block
    UnblockMedia,

    /// Get the auth_chain of a PDU
    GetAuthChain {
        /// An event ID (the $ character followed by the base64 reference hash)
        event_id: Box<EventId>,
    },

    #[command(verbatim_doc_comment)]
    /// Parse and print a PDU from a JSON
    ///
    /// The PDU event is only checked for validity and is not added to the
    /// database.
    ///
    /// [commandbody]()
    /// # ```
    /// # PDU json content here
    /// # ```
    ParsePdu,

    /// Retrieve and print a PDU by ID from the Conduit database
    GetPdu {
        /// An event ID (a $ followed by the base64 reference hash)
        event_id: Box<EventId>,
    },

    /// Print database memory usage statistics
    MemoryUsage,

    /// Clears all of Conduit's database caches with index smaller than the amount
    ClearDatabaseCaches { amount: u32 },

    /// Clears all of Conduit's service caches with index smaller than the amount
    ClearServiceCaches { amount: u32 },

    /// Show configuration values
    ShowConfig,

    /// Reset user password
    ResetPassword {
        /// Username of the user for whom the password should be reset
        username: String,
    },

    /// Create a new user
    CreateUser {
        /// Username of the new user
        username: String,
        /// Password of the new user, if unspecified one is generated
        password: Option<String>,
    },

    /// Temporarily toggle user registration by passing either true or false as an argument, does not persist between restarts
    AllowRegistration { status: Option<bool> },

    /// Disables incoming federation handling for a room.
    DisableRoom { room_id: Box<RoomId> },
    /// Enables incoming federation handling for a room again.
    EnableRoom { room_id: Box<RoomId> },

    /// Sign a json object using Conduit's signing keys, putting the json in a codeblock
    SignJson,

    /// Verify json signatures, putting the json in a codeblock
    VerifyJson,

    /// Parses a JSON object as an event then creates a hash and signs it, putting a room
    /// version as an argument, and the json in a codeblock
    HashAndSignEvent { room_version_id: RoomVersionId },
}

#[derive(Args, Debug)]
#[group(multiple = true, required = false)]
pub struct DeactivatePurgeMediaArgs {
    #[arg(long, short = 'm')]
    /// Purges all media uploaded by the user(s) after deactivating their account
    pub purge_media: bool,

    #[arg(
        long, short = 't',
        value_parser = humantime::parse_duration,
        requires = "purge_media"
    )]
    /// If the --purge-media is present, it only purges media uploaded in the last {time-period}
    ///
    /// Should be in the form specified by humantime::parse_duration
    /// (e.g. 48h, 60min, 10days etc.)
    // --help is unformatted
    #[allow(rustdoc::bare_urls)]
    /// https://docs.rs/humantime/2.2.0/humantime/fn.parse_duration.html
    ///
    /// Note: This will also delete identical media uploaded by other users, so
    /// only use this when all the media they uploaded in this timeframe is undesirable
    pub media_from_last: Option<Duration>,

    #[arg(long, short = 'f', requires = "purge_media")]
    /// If the --purge-media is present, it will also delete identical media uploaded by other
    /// users, ensuring that the file is removed from the media backend, so only use this when all
    /// the media they uploaded is undesirable
    pub force_filehash: bool,
}

#[derive(Args, Debug)]
#[group(required = false)]
pub struct ListMediaArgs {
    #[arg(short, long)]
    /// The user that uploaded the media.
    /// Only local media uploaders can be recorded, so specifying a non-local
    /// user will always yield no results
    pub user: Option<Box<UserId>>,

    #[arg(short, long)]
    /// The server from which the media originated from.
    /// If you want to list local media, just set this to
    /// be your own server's servername
    pub server: Option<Box<ServerName>>,
}